{"componentChunkName":"component---src-templates-blog-post-js","path":"/razones-para-migrar-a-angular/","result":{"data":{"site":{"siteMetadata":{"title":"Diego Boscan"}},"markdownRemark":{"id":"e30a7f4d-27b1-5a4f-b33c-089e3afebf70","excerpt":"La evolución del frontend es impresionante. La web (y JavaScript) cada vez son más potentes. Atrás quedaron los tiempos de jQuery donde el frontend solo…","html":"<p>La evolución del frontend es impresionante. La web (y JavaScript) cada vez son más potentes. Atrás quedaron los tiempos de jQuery donde el frontend solo consistía en hacer animaciones, AJAX y poco más. A partir de la llegada de frameworks como AngularJs, el frontend cambio para siempre.</p>\n<p>Hasta hace unos años AngularJs era un framework muy utilizado, por eso hay muchas aplicaciones (y desarrolladores) que en la actualidad lo siguen usando. Para muestra, en la última encuesta del año 2017 de la web <a href=\"https://2017.stateofjs.com/2017/front-end/results\">State of Js</a>, arroja que de los encuestados <strong>14.300 usaron AngularJs alguna vez</strong> y de ese grupo, unos <strong>4.707 desarrolladores lo usarían nuevamente</strong>.</p>\n<p>Pero es conocido que AngularJS tiene problemas, tanto de rendimiento como de estructura, solamente basta con preguntarse <strong>¿por qué Google decidió reescribirlo desde cero?</strong> Recientemente, anunciaron que la versión 1.7 será la última y <strong>tendrá soporte hasta Junio de 2020</strong>. Es decir, que luego de esa fecha, haciendo una analogia es como usar Windows XP de sistema operativo.</p>\n<p>Si tienes aplicaciones en AngularJs y estás dudoso de actualizar a la versión más actualizada de Angular, acá explico porque en mi opinión debes actualizar lo más pronto posible (ya que tarde o temprano tendrás que reescribir el código).</p>\n<h2>Código mantenible y reutilizable</h2>\n<p>En AngularJs, el código se separaba en controladores, directivas, servicios, vistas. No se desarrollaba orientado a componentes, de manera que era muy frecuente repetir código en varios controladores, usar (y saturar) <code class=\"language-text\">$rootScope</code>, usar two-way data binding en casi todo, etc. Todo esto trae problemas de rendimiento y hacen el mantenimiento cada vez más costoso.</p>\n<p>Con la llegada de los componentes en Angular, ahora se incita a la reusabilidad, se usa menos two-way data binding en favor de los eventos para evitar bugs, entre otros. Además, <strong>Angular utiliza TypeScript</strong>, que entre muchas ventajas, nos ofrece tipado estático, y si tu aplicación es grande, eso es un plus importante.</p>\n<p><img src=\"https://rubygarage.s3.amazonaws.com/uploads/article_image/file/571/2-way-and-1-way-data-binding.jpg\" alt=\"Explicación gráfica de 1-way data binding vs 2-way data binding\"></p>\n<h2>TypeScript</h2>\n<p>La decisión de usar TypeScript para mi fue un acierto. Programar con <strong>tipado estático</strong> es genial, es verdad que en proyectos pequeños o medianos no es tan necesario (es cuestión de preferencia) pero cuando hablamos de un proyecto grande las ventajas son notorias. Programar con TypeScript es resumidamente usar JavaScript más los beneficios de tener tipado estático, interfaces, enums, type assertions, etc.</p>\n<p>Supongamos que tenemos una aplicación de un e-commerce (o de ventas simplemente), con TypeScript podemos crear algo así:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\">\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">User</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">readonly</span> id<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">readonly</span> name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n    balance<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Product</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">readonly</span> name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n    price<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>En el código de arriba, creamos dos interfaces que podemos usar para definir la forma que deben tener los objetos en ciertas situaciones, con esto, TypeScript nos avisa en una etapa temprana de desarrollo si estamos accidentalmente cambiando el nombre de un producto o intentando usar un objeto de tipo <code class=\"language-text\">User</code> que no tiene la propiedad <code class=\"language-text\">balance</code>. Lo podemos ver en el siguiente código:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">buyProduct</span><span class=\"token punctuation\">(</span>user<span class=\"token operator\">:</span> User<span class=\"token punctuation\">,</span> product<span class=\"token operator\">:</span> Product<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    user<span class=\"token punctuation\">.</span>balance <span class=\"token operator\">-=</span> product<span class=\"token punctuation\">.</span>price<span class=\"token punctuation\">;</span> \n    <span class=\"token keyword\">return</span> user<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> user <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>id<span class=\"token operator\">:</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>name<span class=\"token operator\">:</span><span class=\"token string\">\"John\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> product <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>name<span class=\"token operator\">:</span> <span class=\"token string\">\"Apple\"</span><span class=\"token punctuation\">,</span> price<span class=\"token operator\">:</span><span class=\"token number\">100</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">buyProduct</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">,</span> product<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ERROR: Property 'balance' is missing in type '{ id: number; name: string; }'.</span></code></pre></div>\n<p>TypeScript nos indicará que estamos intentando pasarle a esa función un objeto que no tiene las propidades obligatorias, de manera que <strong>capturamos un error antes de que ocurra</strong>. Sino hubiésemos usado una <em>interface</em>, el código fallaría más adelante, y si hacemos muchas operaciones en conjunto, se hará más dificil encontrar el bug. De la misma manera si intentamos accidentalmente cambiar el nombre de un producto una vez creado, el <em>type-checker</em> de TypeScript se encargará de avisarte para que eso no ocurra.</p>\n<p>Además, es menos <em>costoso</em> el ingreso de programadores a los proyectos, <strong>ya que el tipado estático te guía en el desarrollo</strong> y gracias a los tipos puedes mirar el código y entender más fácilmente.</p>\n<h2>Mejor ecosistema</h2>\n<p>Muchas librerías en AngularJs logicámente ya no se mantienen, las personas prefieren dar soporte a una versión más actual donde obtengan mejor rendimiento. Los requerimientos también cambian con el tiempo, ahora cada vez se le exige más al frontend, por eso es mucho más probable que <strong>alguien haya tenido un problema actual y desarrolle una libreria para ello usando Angular a que lo haga en AngularJs</strong>.</p>\n<h2>Mayores facilidades para el desarrollo</h2>\n<p>A parte de darnos una buena estructura para crear aplicaciones escalables y mantenibles, Angular y la mayoría de los frameworks actuales <strong>tienen herramientas que nos facilitan el desarrollo</strong>, como por ejemplo <em>angular-cli</em> (consola de comandos para generar archivos, ejecutar tests, levantar un servidor de desarrollo, etc) o <em>Angular Augury</em> (extensión para Firefox y Google Chrome que nos permite debuggear más fácilmente).</p>\n<p>Además de eso, herramientas como Visual Studio Code o WebStorm soportan Angular (y los frameworks modernos) por defecto.</p>\n<h2>Búsqueda de programadores</h2>\n<p>Por un lado tenemos que la mayoría de las personas que saben AngularJs prefieren trabajar en otras tecnologías que ofrezcan mejores beneficios, y por otro lado tenemos que los programadores nuevos no van a aprender AngularJs y <strong>será cada vez más difícil conseguir gente capacitada</strong>. Si ya es complicado encontrar programadores, que sepan y trabajen con AngularJs será una tarea aún más difícil.</p>\n<h2>Se puede migrar progresivamente</h2>\n<p>Existen varias maneras de migrar aplicaciones AngularJs a la ultima versión estable. <strong>Es posible hacerlo progresivamente</strong> usando herramientas como ngUpgrade, Angular Elements o incluso desarrollando tus propios web components. Por lo tanto, puedes ir migrando a tu tiempo sin necesidad de parar el desarrollo.</p>\n<h2>Conclusión</h2>\n<p>Definitivamente <strong>es una mala idea seguir desarrollando y manteniendo una aplicación AngularJs</strong> en la actualidad. El costo de una migración depende de muchos factores, pero en la gran mayoría de los casos no será fácil, sin embargo, si tienes una aplicacion que estará en producción por varios años más, poniendo todo en una balanza creo que son más los beneficios que el tiempo que se invertira en el proceso.</p>","frontmatter":{"title":"Razones para migrar de AngularJs a Angular","date":"septiembre 17, 2018","description":"Es conocido que AngularJS tiene problemas de rendimiento, solamente basta con preguntarse ¿por qué Google decidio reescribirlo desde cero? Recientemente, anunciaron que la versión 1.7 tendrá soporte hasta Junio de 2020.","featuredImage":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/9f2b2ce4482d0adc7a37070c460d392a/6bc96/angular.png","srcSet":"/static/9f2b2ce4482d0adc7a37070c460d392a/185ef/angular.png 241w,\n/static/9f2b2ce4482d0adc7a37070c460d392a/1c2c4/angular.png 483w,\n/static/9f2b2ce4482d0adc7a37070c460d392a/6bc96/angular.png 965w","sizes":"(min-width: 965px) 965px, 100vw"},"sources":[{"srcSet":"/static/9f2b2ce4482d0adc7a37070c460d392a/8ae26/angular.avif 241w,\n/static/9f2b2ce4482d0adc7a37070c460d392a/10778/angular.avif 483w,\n/static/9f2b2ce4482d0adc7a37070c460d392a/5d551/angular.avif 965w","type":"image/avif","sizes":"(min-width: 965px) 965px, 100vw"},{"srcSet":"/static/9f2b2ce4482d0adc7a37070c460d392a/1a3a1/angular.webp 241w,\n/static/9f2b2ce4482d0adc7a37070c460d392a/e352e/angular.webp 483w,\n/static/9f2b2ce4482d0adc7a37070c460d392a/81e52/angular.webp 965w","type":"image/webp","sizes":"(min-width: 965px) 965px, 100vw"}]},"width":965,"height":428.00000000000006}}}}},"previous":{"fields":{"slug":"/usar-punto-y-coma-en-javascript/"},"frontmatter":{"title":"¿Debería usar punto y coma en JavaScript?"}},"next":{"fields":{"slug":"/decoradores-en-typescript/"},"frontmatter":{"title":"Decoradores en TypeScript"}}},"pageContext":{"id":"e30a7f4d-27b1-5a4f-b33c-089e3afebf70","previousPostId":"67f0fef1-2af5-5531-ab1c-40d29a161d8e","nextPostId":"7cabf0d8-826c-5b0c-a402-96d6ea660f67"}},"staticQueryHashes":["1324386404","3257411868"]}